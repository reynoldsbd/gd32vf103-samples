//! Implements a trivial serial "console" that echoes text back at the user

#![no_std]
#![no_main]

extern crate panic_halt;

use core::fmt::Write;
use core::str::Utf8Error;

use embedded_hal::serial::Read;

use gd32vf103_pac::Peripherals;
use gd32vf103xx_hal::afio::AfioExt;
use gd32vf103xx_hal::gpio::GpioExt;
use gd32vf103xx_hal::rcu::RcuExt;
use gd32vf103xx_hal::serial::{Config, Serial};
use gd32vf103xx_hal::time::U32Ext;


/// Fixed size of internal `LineReader` buffer
const LINE_BUF_LEN: usize = 512;


/// Errors generated by `LineReader::read_line`
#[derive(Debug)]
enum LineReaderError<R>
{
    // Invalid string
    Invalid(Utf8Error),

    // Too large for internal buffer
    Overflow,

    // Error receiving bytes
    Receive(R),
}


/// Reads full lines from a serial connection
///
/// Similar to (but much simpler than) `std::io::BufReader`
struct LineReader<R>
{
    rx: R,
    buf: [u8; LINE_BUF_LEN],
}

impl<R> LineReader<R>
{
    fn new(rx: R) -> Self
    {
        Self { rx, buf: [0; LINE_BUF_LEN] }
    }
}

impl<R> LineReader<R>
where
    R: Read<u8>
{
    /// Reads and returns a full line of text from the serial connection
    fn read_line<T>(&mut self, tx: &mut T) -> Result<&str, LineReaderError<R::Error>>
    where
        T: Write
    {
        let mut index = 0;

        loop
        {
            self.buf[index] = match nb::block!(self.rx.read())
            {
                Ok(c) => c,
                Err(e) => return Err(LineReaderError::Receive(e)),
            };

            let c = char::from(self.buf[index]);

            // Echo characters like a normal console
            let _ = write!(tx, "{}", c);

            if c == '\r'
            {
                let _ = write!(tx, "\n");
                match core::str::from_utf8(&self.buf[..index + 1])
                {
                    Ok(s) => return Ok(s),
                    Err(e) => return Err(LineReaderError::Invalid(e)),
                }
            }
            else
            {
                index += 1;
                if index >= LINE_BUF_LEN
                {
                    return Err(LineReaderError::Overflow);
                }
            }
        }
    }
}


#[riscv_rt::entry]
fn main() -> !
{
    let peripherals = Peripherals::take().unwrap();

    let mut rcu = peripherals.RCU.configure()
        .freeze();

    let mut afio = peripherals.AFIO.constrain(&mut rcu);

    let gpioa = peripherals.GPIOA.split(&mut rcu);
    let tx = gpioa.pa9;
    let rx = gpioa.pa10;

    let config = Config::default()
        .baudrate(115_200.bps());
    let serial = Serial::new(peripherals.USART0, (tx, rx), config, &mut afio, &mut rcu);
    let (mut tx, rx) = serial.split();

    let _ = write!(tx, "Starting echo console...\r\n");
    let mut reader = LineReader::new(rx);

    loop {
        let _ = write!(tx, "> ");
        match reader.read_line(&mut tx)
        {
            Ok(line) =>
            {
                let _ = write!(tx, "{}\r\n", line);
            },

            Err(err) =>
            {
                let _ = write!(tx, "\r\nERROR: {:?}\r\n", err);
            }
        }
    }
}
